var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StaticPermutations","category":"page"},{"location":"#StaticPermutations","page":"Home","title":"StaticPermutations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StaticPermutations]","category":"page"},{"location":"#Base.PermutedDimsArrays.PermutedDimsArray-Union{Tuple{N}, Tuple{p}, Tuple{T}, Tuple{AbstractArray{T, N}, Permutation{p, N}}} where {T, p, N}","page":"Home","title":"Base.PermutedDimsArrays.PermutedDimsArray","text":"PermutedDimsArray(A, perm::AbstractPermutation) -> B\n\nAlternative PermutedDimsArray constructor taking a static permutation.\n\nIn contrast to the base constructors, the returned type is fully inferred here.\n\n\n\n\n\n","category":"method"},{"location":"#Core.Tuple-Union{Tuple{Permutation{p}}, Tuple{p}} where p","page":"Home","title":"Core.Tuple","text":"Tuple(perm::Permutation)\n\nExtract tuple representation of Permutation.\n\nThe result can be passed to permutedims and PermutedDimsArray.\n\nReturns nothing if perm is a NoPermutation.\n\nExamples\n\njulia> Tuple(Permutation(3, 2, 1))\n(3, 2, 1)\n\njulia> Tuple(NoPermutation()) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#StaticPermutations.AbstractPermutation","page":"Home","title":"StaticPermutations.AbstractPermutation","text":"AbstractPermutation\n\nAbstract type representing a compile-time permutation.\n\nSubtypes are Permutation and NoPermutation.\n\n\n\n\n\n","category":"type"},{"location":"#StaticPermutations.NoPermutation","page":"Home","title":"StaticPermutations.NoPermutation","text":"NoPermutation <: AbstractPermutation\n\nRepresents an identity permutation.\n\nIt is functionally equivalent to Permutation(1, 2, 3, ...), and is included for convenience.\n\n\n\n\n\n","category":"type"},{"location":"#StaticPermutations.Permutation","page":"Home","title":"StaticPermutations.Permutation","text":"Permutation{p} <: AbstractPermutation\n\nDescribes a compile-time dimension permutation.\n\nThe type parameter p should be a valid permutation such as (3, 1, 2).\n\n\n\nPermutation(perm::Vararg{Int})\nPermutation(perm::NTuple{N,Int})\n\nConstructs a Permutation.\n\nExample\n\nBoth are equivalent:\n\np1 = Permutation(2, 3, 1)\np2 = Permutation((2, 3, 1))\n\n\n\n\n\n","category":"type"},{"location":"#StaticPermutations.PermutedArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Permutation}} where {T, N}","page":"Home","title":"StaticPermutations.PermutedArray","text":"PermutedArray(A, perm::Permutation) -> B\n\nGiven an AbstractArray A, create a view B such that the dimensions appear to be permuted. Similar to permutedims, except that no copying occurs (B shares storage with A).\n\nExamples\n\njulia> A = rand(3, 5, 4);\n\njulia> B = PermutedArray(A, Permutation(3, 1, 2));\n\njulia> size(B)\n(4, 3, 5)\n\njulia> B[3,1,2] == A[1,2,3]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{NoPermutation, Tuple}","page":"Home","title":"Base.:*","text":"*(p::AbstractPermutation, collection)\n\nApply permutation to the given collection.\n\nThe collection may be a Tuple or a CartesianIndex to be reordered. If p is a Permutation, the collection must have the same length as p.\n\nExamples\n\njulia> p = Permutation(2, 3, 1);\n\njulia> p * (36, 42, 14)\n(42, 14, 36)\n\njulia> p * CartesianIndex(36, 42, 14)\nCartesianIndex(42, 14, 36)\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{Permutation, Permutation}","page":"Home","title":"Base.:*","text":"*(p::AbstractPermutation, q::AbstractPermutation)\n\nCompose two permutations: apply permutation p to permutation q.\n\nNote that permutation composition is non-commutative.\n\nExamples\n\njulia> p = Permutation(2, 3, 1);\n\njulia> q = Permutation(1, 3, 2);\n\njulia> p * q\nPermutation(3, 2, 1)\n\njulia> q * p\nPermutation(2, 1, 3)\n\njulia> p * inv(p)\nPermutation(1, 2, 3)\n\njulia> inv(p) * p\nPermutation(1, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"#Base.:/-Union{Tuple{N}, Tuple{q}, Tuple{p}, Tuple{Permutation{q, N}, Permutation{p, N}}} where {p, q, N}","page":"Home","title":"Base.:/","text":"/(y::AbstractPermutation, x::AbstractPermutation)\n\nGet relative permutation needed to get from x to y. That is, the permutation p such that p * x == y.\n\nExamples\n\njulia> x = Permutation(3, 1, 2);\n\njulia> y = Permutation(2, 1, 3);\n\njulia> p = y / x\nPermutation(3, 2, 1)\n\njulia> p * x == y\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.:\\-Tuple{AbstractPermutation, Any}","page":"Home","title":"Base.:\\","text":"\\(p::AbstractPermutation, x)\n\nUndo permutation p from permuted collection x.\n\nIn other words, apply inverse of permutation p to x. This is effectively equivalent to inv(p) * x.\n\n\n\n\n\n","category":"method"},{"location":"#Base.inv-Tuple{AbstractPermutation}","page":"Home","title":"Base.inv","text":"inv(p::Permutation)\ninvperm(p::Permutation)\n\nReturns the inverse permutation of p.\n\nFunctionally equivalent to Julia's invperm, with the advantage that the result is a compile time constant.\n\nSee also /.\n\nExamples\n\njulia> p = Permutation(2, 3, 1);\n\njulia> q = inv(p)\nPermutation(3, 1, 2)\n\njulia> t_orig = (36, 42, 14);\n\njulia> t_perm = p * t_orig\n(42, 14, 36)\n\njulia> q * t_perm === t_orig\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"#Base.isperm-Tuple{NoPermutation}","page":"Home","title":"Base.isperm","text":"isperm(perm::AbstractPermutation) -> Bool\n\nReturns true if perm is a valid permutation, false otherwise.\n\nThe result is known at compile time.\n\nExamples\n\njulia> isperm(Permutation(3, 1, 2))\ntrue\n\njulia> isperm(Permutation(4, 1, 2))\nfalse\n\njulia> isperm(NoPermutation())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Union{Tuple{Permutation{p}}, Tuple{p}} where p","page":"Home","title":"Base.length","text":"length(perm::AbstractPermutation)\n\nReturns length of permutation.\n\nFor NoPermutation, returns nothing.\n\nExamples\n\njulia> length(Permutation(3, 2, 1))\n3\n\njulia> length(NoPermutation()) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#StaticPermutations.append-Union{Tuple{M}, Tuple{p}, Tuple{Permutation{p}, Val{M}}} where {p, M}","page":"Home","title":"StaticPermutations.append","text":"append(p::Permutation, ::Val{M})\n\nAppend M non-permuted dimensions to the given permutation.\n\nExamples\n\njulia> append(Permutation(2, 3, 1), Val(2))\nPermutation(2, 3, 1, 4, 5)\n\njulia> append(NoPermutation(), Val(2))\nNoPermutation()\n\n\n\n\n\n","category":"method"},{"location":"#StaticPermutations.identity_permutation-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Home","title":"StaticPermutations.identity_permutation","text":"identity_permutation(::Val{N})\nidentity_permutation(A::AbstractArray{T,N})\n\nReturns the identity permutation Permutation(1, 2, ..., N).\n\n\n\n\n\n","category":"method"},{"location":"#StaticPermutations.isidentity-Tuple{NoPermutation}","page":"Home","title":"StaticPermutations.isidentity","text":"isidentity(p::Permutation)\n\nReturns true if p is an identity permutation, i.e. if it is equivalent to (1, 2, 3, ...).\n\njulia> isidentity(Permutation(1, 2, 3))\ntrue\n\njulia> isidentity(Permutation(1, 3, 2))\nfalse\n\njulia> isidentity(NoPermutation())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#StaticPermutations.prepend-Union{Tuple{M}, Tuple{p}, Tuple{Permutation{p}, Val{M}}} where {p, M}","page":"Home","title":"StaticPermutations.prepend","text":"prepend(p::Permutation, ::Val{M})\n\nPrepend M non-permuted dimensions to the given permutation.\n\nExamples\n\njulia> prepend(Permutation(2, 3, 1), Val(2))\nPermutation(1, 2, 4, 5, 3)\n\njulia> prepend(NoPermutation(), Val(2))\nNoPermutation()\n\n\n\n\n\n","category":"method"}]
}
